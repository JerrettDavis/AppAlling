name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  DOTNET_NOLOGO: true
  INCLUDE_SYMBOLS: true
  SOLUTION_PATH: AppAlling.sln
  APP_PROJECT: src/AppAlling.UI.WinForms/AppAlling.UI.WinForms.csproj
  ARTIFACTS_DIR: artifacts

jobs:
  pr-checks:
    if: github.event_name == 'pull_request'
    runs-on: windows-latest
    permissions:
      contents: read
      id-token: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.0.x
          cache: true
          cache-dependency-path: |
            **/packages.lock.json
            global.json

      - name: Restore tools & dependencies
        shell: pwsh
        run: |
          dotnet restore --use-lock-file $env:SOLUTION_PATH
          dotnet tool restore

      - name: Build (Release)
        shell: pwsh
        run: dotnet build $env:SOLUTION_PATH --configuration Release --no-restore /p:ContinuousIntegrationBuild=true

      - name: Test with coverage (Release)
        shell: pwsh
        run: |
          dotnet test $env:SOLUTION_PATH `
            --configuration Release `
            --no-build `
            --collect:"XPlat Code Coverage" `
            -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura `
            -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Include="[AppAlling*]*" `
            -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Exclude="[*Tests]*"

      - name: Install ReportGenerator
        run: dotnet tool update -g dotnet-reportgenerator-globaltool

      - name: Combine coverage and create reports
        shell: pwsh
        run: |
          $reports = (Get-ChildItem -Recurse -Filter "coverage.cobertura.xml" | ForEach-Object { $_.FullName }) -join ";"
          reportgenerator `
            -reports:"$reports" `
            -targetdir:"coverage-report" `
            -reporttypes:"HtmlInline;Cobertura;TextSummary;lcov;Badges" `
            -assemblyfilters:"+AppAlling*;-*Tests*" `
            -filefilters:"-**/*.Tests/*;-**/*Tests*/**"
          "COVERAGE_SUMMARY<<EOF" | Out-File -FilePath $env:GITHUB_ENV -Append
          Get-Content "coverage-report/Summary.txt" | Out-File -FilePath $env:GITHUB_ENV -Append
          "EOF" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Upload coverage HTML report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage-report

      - name: Add coverage summary to PR
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          recreate: true
          message: |
            ## Code Coverage
            ```
            ${{ env.COVERAGE_SUMMARY }}
            ```
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: coverage-report/Cobertura.xml
          flags: unittests
          fail_ci_if_error: true
          verbose: true
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  release:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: windows-latest
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.0.x
          cache: true
          cache-dependency-path: |
            **/packages.lock.json
            global.json

      - name: Restore tools & dependencies
        shell: pwsh
        run: |
          dotnet restore --use-lock-file $env:SOLUTION_PATH
          dotnet tool restore

      - name: Fetch tags
        run: git fetch --prune --tags

      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v1
        with:
          versionSpec: '5.x'

      - name: Run GitVersion
        id: gitversion
        uses: gittools/actions/gitversion/execute@v1

      - name: Set version env vars
        shell: pwsh
        run: |
          "PACKAGE_VERSION=${{ steps.gitversion.outputs.nuGetVersionV2 }}" | Out-File -FilePath $env:GITHUB_ENV -Append
          "ASSEMBLY_VERSION=${{ steps.gitversion.outputs.assemblySemVer }}" | Out-File -FilePath $env:GITHUB_ENV -Append
          "FILE_VERSION=${{ steps.gitversion.outputs.assemblySemFileVer }}" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Build (Release) with version
        shell: pwsh
        run: >
          dotnet build $env:SOLUTION_PATH
          --configuration Release
          --no-restore
          /p:ContinuousIntegrationBuild=true
          /p:Version=${{ env.PACKAGE_VERSION }}
          /p:AssemblyVersion=${{ env.ASSEMBLY_VERSION }}
          /p:FileVersion=${{ env.FILE_VERSION }}
          /p:PackageVersion=${{ env.PACKAGE_VERSION }}

      - name: Test (Release)
        shell: pwsh
        run: dotnet test $env:SOLUTION_PATH --configuration Release --no-build --verbosity normal

      - name: Publish WinForms App (win-x64, self-contained)
        shell: pwsh
        run: >
          dotnet publish $env:APP_PROJECT
          --configuration Release
          --runtime win-x64
          --self-contained true
          /p:PublishSingleFile=true
          /p:IncludeNativeLibrariesForSelfExtract=true
          /p:PublishReadyToRun=true
          /p:Version=${{ env.PACKAGE_VERSION }}
          /p:FileVersion=${{ env.FILE_VERSION }}
          /p:AssemblyVersion=${{ env.ASSEMBLY_VERSION }}
          --output publish/win-x64

      - name: Create App Zip
        shell: pwsh
        run: |
          $zip = "AppAlling-win-x64-v${{ env.PACKAGE_VERSION }}.zip"
          Compress-Archive -Path "publish/win-x64/*" -DestinationPath "$zip"
          New-Item -ItemType Directory -Force -Path artifacts | Out-Null
          Move-Item "$zip" "artifacts/"

      - name: Pack (all packable projects)
        shell: pwsh
        run: >
          dotnet pack $env:SOLUTION_PATH
          --configuration Release
          --no-build
          --output $env:ARTIFACTS_DIR
          /p:ContinuousIntegrationBuild=true
          /p:IncludeSymbols=${{ env.INCLUDE_SYMBOLS }}
          /p:SymbolPackageFormat=snupkg
          /p:Version=${{ env.PACKAGE_VERSION }}
          /p:AssemblyVersion=${{ env.ASSEMBLY_VERSION }}
          /p:FileVersion=${{ env.FILE_VERSION }}
          /p:PackageVersion=${{ env.PACKAGE_VERSION }}

      - name: Upload build artifacts (app + packages)
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts
          path: |
            ./artifacts/*.nupkg
            ./artifacts/*.snupkg
            ./artifacts/*.zip

      - name: Create and push git tag
        shell: pwsh
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
      
          $tag = "v${{ env.PACKAGE_VERSION }}"
      
          # make sure we see remote tags locally
          git fetch --tags --force --prune
      
          # check if the tag exists (exit code == 0 means exists)
          git rev-parse --verify --quiet "refs/tags/$tag" *> $null
          if ($LASTEXITCODE -eq 0) {
            Write-Host "Tag $tag already exists. Skipping tag push."
          } else {
            git tag $tag
            git push origin "refs/tags/$tag"
          }

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.PACKAGE_VERSION }}
          name: Release v${{ env.PACKAGE_VERSION }}
          files: |
            ./artifacts/*.nupkg
            ./artifacts/*.snupkg
            ./artifacts/*.zip
          generate_release_notes: true

      - name: Push to NuGet.org
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        shell: pwsh
        run: |
          if ([string]::IsNullOrWhiteSpace($env:NUGET_API_KEY)) {
            echo "Skipping NuGet.org push: API key not set."
          } else {
            Get-ChildItem artifacts -Filter *.nupkg | ForEach-Object {
              dotnet nuget push $_.FullName `
                --api-key "$env:NUGET_API_KEY" `
                --source https://api.nuget.org/v3/index.json `
                --skip-duplicate
            }
            Get-ChildItem artifacts -Filter *.snupkg | ForEach-Object {
              dotnet nuget push $_.FullName `
                --api-key "$env:NUGET_API_KEY" `
                --source https://api.nuget.org/v3/index.json `
                --skip-duplicate
            }
          }

      - name: Push to GitHub Packages (optional)
        shell: pwsh
        run: |
          Get-ChildItem artifacts -Filter *.nupkg | ForEach-Object {
            dotnet nuget push $_.FullName `
              --source "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json" `
              --api-key "${{ secrets.GITHUB_TOKEN }}" `
              --skip-duplicate
          }
          Get-ChildItem artifacts -Filter *.snupkg | ForEach-Object {
            dotnet nuget push $_.FullName `
              --source "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json" `
              --api-key "${{ secrets.GITHUB_TOKEN }}" `
              --skip-duplicate
          }
